import gymnasium as gym
from gymnasium import error, spaces, utils
from gymnasium.utils import seeding
import numpy as np
import random

from nltk.parse.recursivedescent import RecursiveDescentParser
from nltk.tokenize import wordpunct_tokenize

from .grammargame import GrammarAgent, GrammarEnv
from .netgame import NetGameEnv

class NetGrammarAgent(GrammarAgent):
    def apply_rules(self, rules):
        # run the rules ('program') generated by a grammar, return an action in the sub-environment in which the rules are 
        # meant to describe optimal action
        nenv = self.game_env
        proposed = -1
        for r in rules:
            # use last rule, in case there's more than one
            if r[0] == 'bit0' and r[1] == 'set1':
                for i in range(nenv.nsites):
                    if nenv.state[i] == 0:
                        proposed = i  # first empty site
            if r[0] == 'bit1' and r[1] == 'set0':
                for i in range(nenv.nsites):
                    if nenv.state[i] == 1:
                        proposed = i
        return proposed  # bad rule or no empty sites


class GrammarNetEnv(gym.Env):
    def __init__(self, nsites=10):
        self.grammarstr =  """
        S -> S1 | S2 
        S1 ->  C A  
        S2 ->  C A C A  
        C -> 'bit0' | 'bit1' 
        A -> 'set0' | 'set1' 
        # C -> 'bit0' | 'bit1' | 'bit2' | 'bit3'
        # A -> 'set0' | 'set1' | 'set3' | 'set4' 
        """
        self.grammar_env = GrammarEnv(self.grammarstr, desired_state_len=6)
        self.game_env = NetGameEnv(nsites)

        self.observation_space = self.grammar_env.observation_space
        self.action_space = self.grammar_env.action_space
        self.agent = NetGrammarAgent(self.game_env, self.grammar_env)

    def step(self, action):
        state, reward, done, trunc, rule = self.grammar_env.decode_and_step(action)
        if done or trunc:
            parser = RecursiveDescentParser(self.grammar_env.grammar)
            parsed,  = parser.parse(wordpunct_tokenize(rule['rule']))
            # very much grammar specific code:
            # complete rule has been built; 
            # run episode in network env to evaluate rule
            therule = parsed[0]
            c1 = therule[0][0]
            a1 = therule[1][0]
            parsed_rules = [[c1,a1]]
            if len(therule) == 4:
                c2 = therule[2][0]
                a2 = therule[3][0]
                parsed_rules.append([c2,a2])
            self.game_env.reset()
            subdone = False
            while not subdone:
                subaction = self.agent.apply_rules(parsed_rules)  # bad action/rule -> subaction = -1
                substate, subreward, subdone, subtrunc, _ = self.game_env.step(subaction)
                subdone = subdone or subtrunc
                reward += subreward
#            print ("RULE CREATED  ", rule['rule'], "   ", reward)

        return state, reward, done, trunc, rule

    def get_action_mask(self, state = None):
        return self.grammar_env.get_action_mask(state)
    
    def reset(self, seed = None):
        self.grammar_env.reset()
        self.game_env.reset()
        return self.grammar_env.state, {}


def make_grammarnetgame(nsites = 10):
    env = GrammarNetEnv(nsites)
    return env

def main():
    # random testing of stuff
    grammarstr =  """
    S -> S1 | S2 
    S1 ->  C A  
    S2 ->  C A C A  
    C -> 'bit0' | 'bit1' 
    A -> 'set0' | 'set1' 
    # C -> 'bit0' | 'bit1' | 'bit2' | 'bit3'
    # A -> 'set0' | 'set1' | 'set3' | 'set4' 
    """
    env = NetGameEnv(nsites=10)
    grammar_env = GrammarEnv(grammarstr)
    agent = GrammarAgent(env, grammar_env)
    done = False
    while not done:
#        act = agent.random_action()
        act = agent.truly_random_action()
#        obs, rew, done, trunc, info = grammar_env.step(act)
        obs, rew, done, trunc, info = grammar_env.step_with_mask(act)

if __name__=="__main__":
    main()
